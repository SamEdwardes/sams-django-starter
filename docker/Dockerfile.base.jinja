# See these blog posts for reference:
# - https://rob.cogit8.org/posts/optimizing-django-docker-builds-with-astrals-uv/
# - https://hynek.me/articles/docker-uv/

FROM python:3.13.5-alpine

# Install uv
COPY --from=ghcr.io/astral-sh/uv:0.5.5 /uv /uvx /bin/

# - Silence uv complaining about not being able to use hard links,
# - tell uv to byte-compile packages for faster application startups,
# - prevent uv from accidentally downloading isolated Python builds,
# - and finally declare `/app` as the target for `uv sync`.
ENV UV_LINK_MODE=copy \
  UV_COMPILE_BYTECODE=1 \
  UV_PYTHON_DOWNLOADS=never \
  UV_PYTHON=python3.13

# Synchronize DEPENDENCIES without the application itself.
# This layer is cached until uv.lock or pyproject.toml change, which are
# only temporarily mounted into the build container since we don't need
# them in the production one.
# You can create `/app` using `uv venv` in a separate `RUN`
# step to have it cached, but with uv it's so fast, it's not worth
# it, so we let `uv sync` create it for us auto magically.
WORKDIR /app

RUN --mount=type=cache,target=/root/.cache \
  --mount=type=bind,source=uv.lock,target=uv.lock \
  --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
  uv sync \
  --locked \
  --no-dev \
  --no-install-project

# Now install the  APPLICATION w/o dependencies (deps were installed in the last step)
COPY manage.py /app/
COPY templates /app/templates/
COPY {{ project_name }} /app/{{ project_name }}/
COPY {{ app_name }} /app/{{ app_name }}/

RUN --mount=type=cache,target=/root/.cache \
  --mount=type=bind,source=uv.lock,target=uv.lock \
  --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
  uv sync \
  --locked \
  --no-dev \
  --no-editable
